/**
 * chat.js
 * â”€â”€â”€â”€â”€â”€â”€
 * Manages the chat panel:
 *  - Populating the chat dropdown when an agent is selected
 *  - Loading messages for the selected chat (with infinite-scroll pagination)
 *  - Rendering text and audio message bubbles
 *  - Sending text messages and audio messages
 *  - Showing a "loading..." agent bubble while waiting for a response
 *
 * Negative index pagination logic:
 *  - First load: start_index = -1, n = 10  â†’ returns the newest 10 messages
 *  - Next page:  start_index = -(loadedCount + 1), n = 10
 *  - When API returns 0 messages, we've reached the beginning
 *
 * Depends on: api.js, config.js, audio.js
 */

const Chat = (() => {

  // â”€â”€â”€ DOM references â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const chatsSelect  = document.getElementById("chats-select");
  const newChatBtn   = document.getElementById("new-chat-btn");
  const messagesArea = document.getElementById("messages-area");
  const chatBeginLbl = document.getElementById("chat-begin-label");
  const messageInput = document.getElementById("message-input");
  const sendBtn      = document.getElementById("send-btn");

  // â”€â”€â”€ Internal state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let _currentAgentId   = null;
  let _currentChatId    = null;
  let _loadedMessages   = 0;    // how many messages have been loaded so far
  let _reachedBeginning = false; // true once the API returns 0 messages
  let _isLoadingMore    = false; // guard against concurrent scroll loads

  // â”€â”€â”€ Agent selection: populate chat dropdown â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Called by agents.js when a user selects an agent.
   * @param {object} agentDetail - { id, name, system_prompt, chats: [...] }
   */
  function loadAgent(agentDetail) {
    _currentAgentId = agentDetail.id;

    // Populate the chat select dropdown
    chatsSelect.innerHTML = "";
    agentDetail.chats.forEach(chat => addChatOption(chat));

    // Reset chat state
    clearMessages();

    if (agentDetail.chats.length > 0) {
      // Auto-select the first chat
      chatsSelect.value = String(agentDetail.chats[0].id);
      loadChat(agentDetail.chats[0].id);
    } else {
      // No chats yet â€” prompt user to create one
      _currentChatId = null;
      showPlaceholder("No chats yet. Click 'New Chat' to start.");
    }
  }

  /**
   * Add a chat to the <select> dropdown.
   */
  function addChatOption(chat) {
    const option = document.createElement("option");
    option.value       = chat.id;
    option.textContent = chat.name;
    chatsSelect.appendChild(option);
  }

  // â”€â”€â”€ Chat selection from dropdown â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  chatsSelect.addEventListener("change", () => {
    const chatId = Number(chatsSelect.value);
    if (chatId) loadChat(chatId);
  });

  // â”€â”€â”€ New Chat button â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  newChatBtn.addEventListener("click", async () => {
    if (!_currentAgentId) {
      alert("Please select an agent first.");
      return;
    }

    try {
      // Create a new chat (name is auto-generated by the server)
      const newChat = await API.post("/chats/", { agent_id: _currentAgentId });

      addChatOption(newChat);
      chatsSelect.value = String(newChat.id);
      loadChat(newChat.id);

    } catch (err) {
      alert("Failed to create chat: " + err.message);
    }
  });

  // â”€â”€â”€ Load messages for a chat â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Load the most recent 10 messages for the given chat.
   * Resets all pagination state.
   */
  async function loadChat(chatId) {
    _currentChatId    = chatId;
    _loadedMessages   = 0;
    _reachedBeginning = false;

    clearMessages();

    await loadMoreMessages(/* prepend = */ false);

    // Scroll to bottom to show newest messages
    scrollToBottom();
  }

  /**
   * Fetch the next page of older messages and prepend them to the chat.
   * @param {boolean} prepend - false on initial load, true on scroll-up
   */
  async function loadMoreMessages(prepend = true) {
    if (_reachedBeginning || _isLoadingMore || !_currentChatId) return;

    _isLoadingMore = true;

    // Show "loading..." at the top while fetching
    let loadingEl = null;
    if (prepend) {
      loadingEl = showTopLoader();
    }

    try {
      // start_index: -1 for first load, then -(loadedSoFar + 1) for older pages
      const startIndex = _loadedMessages === 0 ? -1 : -(_loadedMessages + 1);
      const messages   = await API.get(
        `/chats/${_currentChatId}/messages/?start_index=${startIndex}&n=${CONFIG.MESSAGES_PER_PAGE}`
      );

      if (prepend && loadingEl) loadingEl.remove();

      if (!messages || messages.length === 0) {
        // No more messages â€” we've reached the very beginning
        _reachedBeginning = true;
        chatBeginLbl.classList.remove("hidden");
        return;
      }

      // Messages arrive newest-first from this call; reverse to show oldest first on prepend
      const ordered = prepend ? [...messages].reverse() : messages;

      // Remember scroll position before prepending so we can restore it
      const scrollHeightBefore = messagesArea.scrollHeight;

      for (const msg of ordered) {
        await renderMessage(msg, prepend);
      }

      _loadedMessages += messages.length;

      // After prepending older messages, keep the scroll position so user
      // doesn't jump back to the top
      if (prepend) {
        const added = messagesArea.scrollHeight - scrollHeightBefore;
        messagesArea.scrollTop += added;
      }

    } catch (err) {
      if (prepend && loadingEl) loadingEl.remove();
      console.error("Failed to load messages:", err);
    } finally {
      _isLoadingMore = false;
    }
  }

  // â”€â”€â”€ Scroll-up pagination trigger â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  messagesArea.addEventListener("scroll", () => {
    // When scrolled to within 60px of the top, load older messages
    if (messagesArea.scrollTop < 60 && !_reachedBeginning && !_isLoadingMore) {
      loadMoreMessages(true);
    }
  });

  // â”€â”€â”€ Send message â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  sendBtn.addEventListener("click", handleSend);
  messageInput.addEventListener("keydown", (e) => {
    // Send on Enter (but not Shift+Enter)
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  });

  async function handleSend() {
    if (!_currentChatId) {
      alert("Please select or create a chat first.");
      return;
    }

    const hasAudio = AudioManager.hasRecording();
    const text     = messageInput.value.trim();

    if (!hasAudio && !text) return; // nothing to send

    sendBtn.disabled = true;
    messageInput.value = "";

    try {
      if (hasAudio) {
        await sendAudioMessage();
      } else {
        await sendTextMessage(text);
      }
    } catch (err) {
      console.error("Send failed:", err);
      alert("Failed to send message: " + err.message);
    } finally {
      sendBtn.disabled = false;
    }
  }

  // â”€â”€â”€ Text message flow â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  async function sendTextMessage(text) {
    // 1. Immediately show user's message bubble
    const userMsg = {
      id: null, // no real ID yet (we'll get it from the server)
      sender: "user",
      is_audio: false,
      text: text,
      sent_at: new Date().toISOString(),
    };
    await renderMessage(userMsg, false);
    scrollToBottom();

    // 2. Show "loading..." agent bubble
    const loadingBubble = appendLoadingBubble();
    scrollToBottom();

    // 3. Call the API
    const agentResponse = await API.post("/send/", {
      chat_id: _currentChatId,
      text: text,
    });

    // 4. Replace loading bubble with real response
    loadingBubble.remove();
    await renderMessage(agentResponse, false);
    scrollToBottom();
  }

  // â”€â”€â”€ Audio message flow â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  async function sendAudioMessage() {
    // 1. Upload the recorded audio â†’ get message_id
    const audioMessageId = await AudioManager.uploadRecording(_currentChatId);
    AudioManager.clearAfterSend();

    // 2. Show user's audio bubble (optimistic; we already have the id)
    const userAudioMsg = {
      id: audioMessageId,
      sender: "user",
      is_audio: true,
      text: "",
      sent_at: new Date().toISOString(),
    };
    await renderMessage(userAudioMsg, false);
    scrollToBottom();

    // 3. Show "loading..." for agent
    const loadingBubble = appendLoadingBubble();
    scrollToBottom();

    // 4. Send to the AI using the audio message id
    const agentResponse = await API.post("/send/", {
      chat_id: _currentChatId,
      audio: audioMessageId,
    });

    // 5. Replace loading bubble with agent response
    loadingBubble.remove();
    await renderMessage(agentResponse, false);
    scrollToBottom();
  }

  // â”€â”€â”€ Message rendering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Create and insert a message bubble into the DOM.
   * @param {object}  msg     - message object from the API
   * @param {boolean} prepend - true = insert at top (older messages), false = append at bottom
   */
  async function renderMessage(msg, prepend) {
    const isUser = msg.sender === "user";

    // Outer row (sets alignment)
    const row = document.createElement("div");
    row.className = `message-row ${isUser ? "user" : "agent"}`;

    // Bubble
    const bubble = document.createElement("div");
    bubble.className = "bubble";

    if (msg.is_audio) {
      // â”€â”€ Audio message â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      bubble.innerHTML = `<div class="audio-bubble"><span>${isUser ? "ðŸŽ™ Voice message" : "ðŸ”Š Audio response"}</span><audio controls></audio></div>`;

      const audioEl = bubble.querySelector("audio");

      // Resolve audio: check cache first, then download
      try {
        const url = await AudioManager.resolveAudioUrl(msg);
        audioEl.src = url;
      } catch (err) {
        audioEl.insertAdjacentHTML("afterend", `<small style="color:red">Could not load audio</small>`);
        console.error("Audio resolution failed:", err);
      }
    } else {
      // â”€â”€ Text message â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      bubble.textContent = msg.text;
    }

    // Timestamp
    const time = document.createElement("div");
    time.className = "message-time";
    time.textContent = formatTime(msg.sent_at);

    row.appendChild(bubble);
    row.appendChild(time);

    // Insert into DOM
    if (prepend) {
      // Insert after the "chat begins" label (which is always first)
      const firstChild = chatBeginLbl.nextSibling;
      messagesArea.insertBefore(row, firstChild);
    } else {
      messagesArea.appendChild(row);
    }
  }

  // â”€â”€â”€ Loading indicator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /** Show a yellow "loading..." bubble in the agent position. */
  function appendLoadingBubble() {
    const row = document.createElement("div");
    row.className = "message-row agent";
    row.innerHTML = `<div class="bubble loading">Agent is thinkingâ€¦</div>`;
    messagesArea.appendChild(row);
    return row;
  }

  /** Show a grey spinner row at the very top during pagination. */
  function showTopLoader() {
    const el = document.createElement("div");
    el.className = "loading-top";
    el.textContent = "Loading earlier messagesâ€¦";
    // Insert right after the "chat begins" label
    messagesArea.insertBefore(el, chatBeginLbl.nextSibling);
    return el;
  }

  // â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function clearMessages() {
    // Remove all children except the "chat begins" label (which is always in the DOM)
    Array.from(messagesArea.children).forEach(child => {
      if (child.id !== "chat-begin-label") child.remove();
    });
    chatBeginLbl.classList.add("hidden");
    _loadedMessages   = 0;
    _reachedBeginning = false;
  }

  function scrollToBottom() {
    messagesArea.scrollTop = messagesArea.scrollHeight;
  }

  function showPlaceholder(text) {
    const el = document.createElement("div");
    el.className = "chat-begin-label";
    el.style.marginTop = "2rem";
    el.textContent = text;
    messagesArea.appendChild(el);
  }

  /**
   * Format an ISO timestamp to a short HH:MM AM/PM string.
   * Falls back gracefully if the date is invalid.
   */
  function formatTime(isoString) {
    if (!isoString) return "";
    try {
      return new Date(isoString).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    } catch {
      return "";
    }
  }

  return { loadAgent };

})();
